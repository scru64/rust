//! # SCRU64: Sortable, Clock-based, Realm-specifically Unique identifier
//!
//! SCRU64 ID offers compact, time-ordered unique identifiers generated by
//! distributed nodes. SCRU64 has the following features:
//!
//! - 63-bit non-negative integer storable as signed/unsigned 64-bit integer
//! - Sortable by generation time (as integer and as text)
//! - 12-digit case-insensitive textual representation (Base36)
//! - ~38-bit Unix epoch-based timestamp that ensures useful life until year 4261
//! - Variable-length node/machine ID and counter fields that share 24 bits
//!
//! ```rust
//! # unsafe { std::env::set_var("SCRU64_NODE_SPEC", "42/8") };
//! // pass node ID through environment variable
//! // (e.g., SCRU64_NODE_SPEC=42/8 command ...)
//!
//! // generate a new identifier object
//! let x = scru64::new_sync();
//! println!("{}", x); // e.g., "0u2r85hm2pt3"
//! println!("{}", x.to_u64()); // as a 64-bit unsigned integer
//!
//! // generate a textual representation directly
//! println!("{}", scru64::new_string_sync()); // e.g., "0u2r85hm2pt4"
//! ```
//!
//! See [SCRU64 Specification] for details.
//!
//! SCRU64's uniqueness is realm-specific, i.e., dependent on the centralized
//! assignment of node ID to each generator. If you need decentralized, globally
//! unique time-ordered identifiers, consider [SCRU128].
//!
//! [SCRU64 Specification]: https://github.com/scru64/spec
//! [SCRU128]: https://github.com/scru128/spec
//!
//! ## Crate features
//!
//! Default features:
//!
//! - `std` integrates the library with, among others, the system clock to draw
//!   current timestamps. Without `std`, this crate provides limited functionality
//!   available under `no_std` environments.
//! - `global_gen` (implies `std`) enables the [`new()`], [`new_string()`], [`new_sync()`],
//!   and [`new_string_sync()`] primary entry point functions as well as the
//!   process-wide global generator under the hood.
//!
//! Optional features:
//!
//! - `serde` enables serialization/deserialization via serde.

#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(docsrs, feature(doc_cfg))]

pub mod generator;
pub mod id;

pub use generator::Scru64Generator;
pub use id::Scru64Id;

#[cfg(feature = "global_gen")]
#[cfg_attr(docsrs, doc(cfg(feature = "global_gen")))]
pub use shortcut::{new, new_string, new_string_sync, new_sync};

#[cfg(test)]
mod test_cases;

/// The total size in bits of the `node_id` and `counter` fields.
const NODE_CTR_SIZE: u8 = 24;

#[cfg(feature = "global_gen")]
mod shortcut {
    use std::{future::Future, thread, time};

    use crate::{generator::GlobalGenerator, Scru64Id};

    const DELAY: time::Duration = time::Duration::from_millis(64);

    /// Generates a new SCRU64 ID object using the global generator.
    #[doc = concat!("\n\n", include_str!("generator/doc_global_gen.md"), "\n\n")]
    ///
    /// This function usually returns a value immediately, but if not possible, it sleeps and waits
    /// for the next timestamp tick.
    ///
    /// # Panics
    ///
    /// Panics if the global generator is not properly configured.
    pub async fn new() -> Scru64Id {
        if let Some(value) = GlobalGenerator.generate() {
            value
        } else {
            spawn_thread(new_sync).await
        }
    }

    /// Generates a new SCRU64 ID encoded in the 12-digit canonical string representation using the
    /// global generator.
    #[doc = concat!("\n\n", include_str!("generator/doc_global_gen.md"), "\n\n")]
    ///
    /// This function usually returns a value immediately, but if not possible, it sleeps and waits
    /// for the next timestamp tick.
    ///
    /// # Panics
    ///
    /// Panics if the global generator is not properly configured.
    pub async fn new_string() -> String {
        if let Some(value) = GlobalGenerator.generate() {
            value.into()
        } else {
            spawn_thread(new_string_sync).await
        }
    }

    /// Generates 200k monotonically increasing IDs.
    #[cfg(test)]
    #[tokio::test]
    async fn test_async() {
        let _ = GlobalGenerator.initialize("42/8".parse().unwrap());

        let mut prev = new().await;
        for _ in 0..100_000 {
            let curr = new().await;
            assert!(prev < curr);
            prev = curr;
        }

        let mut prev = String::from(prev);
        for _ in 0..100_000 {
            let curr = new_string().await;
            assert!(prev < curr);
            prev = curr;
        }
    }

    /// Generates a new SCRU64 ID object using the global generator.
    #[doc = concat!("\n\n", include_str!("generator/doc_global_gen.md"), "\n\n")]
    ///
    /// This function usually returns a value immediately, but if not possible, it sleeps and waits
    /// for the next timestamp tick. It employs blocking sleep to wait; see [`new`] for the
    /// non-blocking equivalents.
    ///
    /// # Panics
    ///
    /// Panics if the global generator is not properly configured.
    pub fn new_sync() -> Scru64Id {
        loop {
            if let Some(value) = GlobalGenerator.generate() {
                break value;
            } else {
                thread::sleep(DELAY);
            }
        }
    }

    /// Generates a new SCRU64 ID encoded in the 12-digit canonical string representation using the
    /// global generator.
    #[doc = concat!("\n\n", include_str!("generator/doc_global_gen.md"), "\n\n")]
    ///
    /// This function usually returns a value immediately, but if not possible, it sleeps and waits
    /// for the next timestamp tick. It employs blocking sleep to wait; see [`new_string`] for the
    /// non-blocking equivalents.
    ///
    /// # Panics
    ///
    /// Panics if the global generator is not properly configured.
    pub fn new_string_sync() -> String {
        new_sync().into()
    }

    /// Generates 200k monotonically increasing IDs.
    #[cfg(test)]
    #[test]
    fn test_sync() {
        let _ = GlobalGenerator.initialize("42/8".parse().unwrap());

        let mut prev = new_sync();
        for _ in 0..100_000 {
            let curr = new_sync();
            assert!(prev < curr);
            prev = curr;
        }

        let mut prev = String::from(prev);
        for _ in 0..100_000 {
            let curr = new_string_sync();
            assert!(prev < curr);
            prev = curr;
        }
    }

    /// Executes a blocking function in a new thread, returning a [`Future`] to await the result.
    ///
    /// Each call to this function spawns a new thread that calls the blocking function and wakes
    /// the current task after execution. This function is small and works with any async executors,
    /// while being suboptimal from the performance perspective.
    #[cold]
    fn spawn_thread<F, T>(blocking_fn: F) -> impl Future<Output = T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static,
    {
        use std::{future, sync, task};

        let state: (Option<T>, Option<task::Waker>) = (None, None);
        let state_in_thread = sync::Arc::new(sync::Mutex::new(state));
        let state_in_future = state_in_thread.clone();

        thread::Builder::new()
            .name("scru64-sleep".into())
            .spawn(move || {
                let output = blocking_fn();
                let mut state = state_in_thread.lock().unwrap();
                state.0 = Some(output);
                if let Some(waker) = state.1.take() {
                    waker.wake();
                }
            })
            .expect("could not spawn scru64-sleep thread");

        future::poll_fn(move |cx| {
            let mut state = state_in_future.lock().unwrap();
            match state.0.take() {
                Some(output) => task::Poll::Ready(output),
                None => {
                    match state.1.as_mut() {
                        Some(waker) => waker.clone_from(cx.waker()),
                        None => state.1 = Some(cx.waker().clone()),
                    }
                    task::Poll::Pending
                }
            }
        })
    }

    /// Tests if the function is executed asynchronously.
    #[cfg(test)]
    #[tokio::test]
    async fn test_spawn_thread() {
        let blocking_fn = || {
            thread::sleep(DELAY);
            42
        };

        let start = time::Instant::now();
        let output = spawn_thread(blocking_fn).await;
        let elapsed = time::Instant::now().duration_since(start);
        assert!(DELAY <= elapsed && elapsed < DELAY * 2);
        assert_eq!(output, 42);

        let start = time::Instant::now();
        tokio::join!(
            spawn_thread(blocking_fn),
            spawn_thread(blocking_fn),
            spawn_thread(blocking_fn),
            spawn_thread(blocking_fn),
        );
        let elapsed = time::Instant::now().duration_since(start);
        assert!(DELAY <= elapsed && elapsed < DELAY * 2);
    }
}
