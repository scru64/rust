//! # SCRU64: Sortable, Clock-based, Realm-specifically Unique identifier
//!
//! SCRU64 ID offers compact, time-ordered unique identifiers generated by
//! distributed nodes. SCRU64 has the following features:
//!
//! - 63-bit non-negative integer storable as signed/unsigned 64-bit integer
//! - Sortable by generation time (as integer and as text)
//! - 12-digit case-insensitive textual representation (Base36)
//! - ~38-bit Unix epoch-based timestamp that ensures useful life until year 4261
//! - Variable-length node/machine ID and counter fields that share 24 bits
//!
//! ```rust
//! # unsafe { std::env::set_var("SCRU64_NODE_SPEC", "42/8") };
//! // pass node ID through environment variable
//! // (e.g., SCRU64_NODE_SPEC=42/8 command ...)
//!
//! // generate a new identifier object
//! let x = scru64::new_sync();
//! println!("{}", x); // e.g., "0u2r85hm2pt3"
//! println!("{}", x.to_u64()); // as a 64-bit unsigned integer
//!
//! // generate a textual representation directly
//! println!("{}", scru64::new_string_sync()); // e.g., "0u2r85hm2pt4"
//! ```
//!
//! See [SCRU64 Specification] for details.
//!
//! SCRU64's uniqueness is realm-specific, i.e., dependent on the centralized
//! assignment of node ID to each generator. If you need decentralized, globally
//! unique time-ordered identifiers, consider [SCRU128].
//!
//! [SCRU64 Specification]: https://github.com/scru64/spec
//! [SCRU128]: https://github.com/scru128/spec
//!
//! ## Crate features
//!
//! Default features:
//!
//! - `std` integrates the library with, among others, the system clock to draw
//!   current timestamps. Without `std`, this crate provides limited functionality
//!   available under `no_std` environments.
//! - `global_gen` (implies `std`) enables the [`new()`], [`new_string()`], [`new_sync()`],
//!   and [`new_string_sync()`] primary entry point functions as well as the
//!   process-wide global generator under the hood.
//!
//! Optional features:
//!
//! - `serde` enables serialization/deserialization via serde.

#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(docsrs, feature(doc_cfg))]

pub mod generator;
#[doc(hidden)]
pub use generator as r#gen;
pub mod id;

pub use generator::Scru64Generator;
pub use id::Scru64Id;

#[cfg(feature = "global_gen")]
#[cfg_attr(docsrs, doc(cfg(feature = "global_gen")))]
pub use shortcut::{new, new_string, new_string_sync, new_sync};

#[cfg(test)]
mod test_cases;

/// The total size in bits of the `node_id` and `counter` fields.
const NODE_CTR_SIZE: u8 = 24;

#[cfg(feature = "global_gen")]
mod shortcut {
    use std::{future::Future, thread, time};

    use crate::{generator::GlobalGenerator, Scru64Id};

    const DELAY: time::Duration = time::Duration::from_millis(64);

    /// Generates a new SCRU64 ID object using the global generator.
    #[doc = concat!("\n\n", include_str!("generator/doc_global_gen.md"), "\n\n")]
    ///
    /// This function usually returns a value immediately, but if not possible, it sleeps and waits
    /// for the next timestamp tick.
    ///
    /// # Panics
    ///
    /// Panics if the global generator is not properly configured.
    pub async fn new() -> Scru64Id {
        loop {
            if let Some(value) = GlobalGenerator.generate() {
                break value;
            } else {
                sleep_in_new_thread(DELAY).await;
            }
        }
    }

    /// Generates a new SCRU64 ID encoded in the 12-digit canonical string representation using the
    /// global generator.
    #[doc = concat!("\n\n", include_str!("generator/doc_global_gen.md"), "\n\n")]
    ///
    /// This function usually returns a value immediately, but if not possible, it sleeps and waits
    /// for the next timestamp tick.
    ///
    /// # Panics
    ///
    /// Panics if the global generator is not properly configured.
    pub async fn new_string() -> String {
        new().await.into()
    }

    /// Generates 100k monotonically increasing IDs.
    #[cfg(test)]
    #[tokio::test]
    async fn test_async() {
        let _ = GlobalGenerator.initialize("42/8".parse().unwrap());

        let mut prev = new_string().await;
        for _ in 0..100_000 {
            let curr = new_string().await;
            assert!(prev < curr);
            prev = curr;
        }
    }

    /// Generates a new SCRU64 ID object using the global generator.
    #[doc = concat!("\n\n", include_str!("generator/doc_global_gen.md"), "\n\n")]
    ///
    /// This function usually returns a value immediately, but if not possible, it sleeps and waits
    /// for the next timestamp tick. It employs blocking sleep to wait; see [`new`] for the
    /// non-blocking equivalents.
    ///
    /// # Panics
    ///
    /// Panics if the global generator is not properly configured.
    pub fn new_sync() -> Scru64Id {
        loop {
            if let Some(value) = GlobalGenerator.generate() {
                break value;
            } else {
                thread::sleep(DELAY);
            }
        }
    }

    /// Generates a new SCRU64 ID encoded in the 12-digit canonical string representation using the
    /// global generator.
    #[doc = concat!("\n\n", include_str!("generator/doc_global_gen.md"), "\n\n")]
    ///
    /// This function usually returns a value immediately, but if not possible, it sleeps and waits
    /// for the next timestamp tick. It employs blocking sleep to wait; see [`new_string`] for the
    /// non-blocking equivalents.
    ///
    /// # Panics
    ///
    /// Panics if the global generator is not properly configured.
    pub fn new_string_sync() -> String {
        new_sync().into()
    }

    /// Generates 100k monotonically increasing IDs.
    #[cfg(test)]
    #[test]
    fn test_sync() {
        let _ = GlobalGenerator.initialize("42/8".parse().unwrap());

        let mut prev = new_string_sync();
        for _ in 0..100_000 {
            let curr = new_string_sync();
            assert!(prev < curr);
            prev = curr;
        }
    }

    /// Suspends execution asynchronously for at least the specified amount of time.
    ///
    /// Each call to this function spawns a new thread that calls [`std::thread::sleep`] and wakes
    /// the current task after that. This function is small and works with any async executors,
    /// while being suboptimal from the performance perspective compared to alternatives like
    /// `tokio::time::sleep`.
    #[cold]
    fn sleep_in_new_thread(duration: time::Duration) -> impl Future<Output = ()> {
        use std::{pin::Pin, sync, task};

        struct Sleep {
            state: sync::Arc<sync::Mutex<(task::Poll<()>, Option<task::Waker>)>>,
        }

        let return_value = Sleep {
            state: sync::Arc::new(sync::Mutex::new((task::Poll::Pending, None))),
        };

        impl Future for Sleep {
            type Output = ();

            fn poll(self: Pin<&mut Self>, cx: &mut task::Context<'_>) -> task::Poll<Self::Output> {
                let mut state = self.state.lock().unwrap();
                if state.0.is_pending() {
                    match state.1.as_mut() {
                        Some(waker) => waker.clone_from(cx.waker()),
                        None => state.1 = Some(cx.waker().clone()),
                    }
                }
                state.0
            }
        }

        let state_in_new_thread = return_value.state.clone();
        thread::spawn(move || {
            thread::sleep(duration);
            let mut state = state_in_new_thread.lock().unwrap();
            state.0 = task::Poll::Ready(());
            if let Some(waker) = state.1.take() {
                waker.wake();
            }
        });

        return_value
    }
}
